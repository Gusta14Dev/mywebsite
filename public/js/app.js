/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var typeit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typeit */ \"./node_modules/typeit/dist/index.es.js\");\n__webpack_require__(/*! ./bootstrap */ \"./resources/js/bootstrap.js\");\n\nnew typeit__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"#typing\", {\n  speed: 250,\n  waitUntilVisible: true,\n  loop: true\n}).type('WEB').pause(1000)[\"delete\"](3).type('PHP').pause(1000)[\"delete\"](3).type('LARAVEL').pause(1000)[\"delete\"](7).type('FULLSTACK').pause(1000)[\"delete\"](9).go();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzIiwibWFwcGluZ3MiOiI7O0FBQUFBLG1CQUFPLENBQUMsZ0RBQWEsQ0FBQztBQUVNO0FBRTVCLElBQUlDLDhDQUFNLENBQUMsU0FBUyxFQUFFO0VBQ2RDLEtBQUssRUFBRSxHQUFHO0VBQ1ZDLGdCQUFnQixFQUFFLElBQUk7RUFDdEJDLElBQUksRUFBRTtBQUNWLENBQUMsQ0FBQyxDQUNEQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQ1hDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFDTCxDQUFDLENBQUMsQ0FBQyxDQUNURCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQ1hDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFDTCxDQUFDLENBQUMsQ0FBQyxDQUNURCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQ2ZDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFDTCxDQUFDLENBQUMsQ0FBQyxDQUNURCxJQUFJLENBQUMsV0FBVyxDQUFDLENBQ2pCQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FDVEMsRUFBRSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYXBwLmpzP2NlZDYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9ib290c3RyYXAnKTtcblxuaW1wb3J0IFR5cGVJdCBmcm9tIFwidHlwZWl0XCI7XG5cbm5ldyBUeXBlSXQoXCIjdHlwaW5nXCIsIHtcbiAgICAgICAgc3BlZWQ6IDI1MCxcbiAgICAgICAgd2FpdFVudGlsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICB9KVxuICAgIC50eXBlKCdXRUInKVxuICAgIC5wYXVzZSgxMDAwKVxuICAgIC5kZWxldGUoMylcbiAgICAudHlwZSgnUEhQJylcbiAgICAucGF1c2UoMTAwMClcbiAgICAuZGVsZXRlKDMpXG4gICAgLnR5cGUoJ0xBUkFWRUwnKVxuICAgIC5wYXVzZSgxMDAwKVxuICAgIC5kZWxldGUoNylcbiAgICAudHlwZSgnRlVMTFNUQUNLJylcbiAgICAucGF1c2UoMTAwMClcbiAgICAuZGVsZXRlKDkpXG4gICAgLmdvKCk7Il0sIm5hbWVzIjpbInJlcXVpcmUiLCJUeXBlSXQiLCJzcGVlZCIsIndhaXRVbnRpbFZpc2libGUiLCJsb29wIiwidHlwZSIsInBhdXNlIiwiZ28iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ (() => {

eval("// import Alpine from 'alpinejs';\n// window.Alpine = Alpine;\n// Alpine.start();\n\n/**\n * Echo exposes an expressive API for subscribing to channels and listening\n * for events that are broadcast by Laravel. Echo and event broadcasting\n * allows your team to easily build robust real-time web applications.\n */\n\n// import Echo from 'laravel-echo'\n\n// window.Pusher = require('pusher-js');\n\n// window.Echo = new Echo({\n//     broadcaster: 'pusher',\n//     key: process.env.MIX_PUSHER_APP_KEY,\n//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n//     forceTLS: true\n// });\n\n// window.toastr = require('toastr');\n\n// toastr.options = {\n//     \"closeButton\": true,\n//     \"debug\": false,\n//     \"newestOnTop\": false,\n//     \"progressBar\": true,\n//     \"positionClass\": \"toast-top-right\",\n//     \"preventDuplicates\": false,\n//     \"onclick\": null,\n//     \"showDuration\": \"300\",\n//     \"hideDuration\": \"1000\",\n//     \"timeOut\": \"5000\",\n//     \"extendedTimeOut\": \"1000\",\n//     \"showEasing\": \"swing\",\n//     \"hideEasing\": \"linear\",\n//     \"showMethod\": \"fadeIn\",\n//     \"hideMethod\": \"fadeOut\"\n// }\n\n// window.livewire.on('toastr', response => {\n//     toastr[response['type']](response['message'], response['title']);\n// });\n\n// document.addEventListener('livewire:load', function () {\n//     window.livewire.on('toastr', response => {\n//         toastr[response['type']](response['message'], response['title']);\n//     });\n// })//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9ib290c3RyYXAuanM/NmRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgQWxwaW5lIGZyb20gJ2FscGluZWpzJztcbi8vIHdpbmRvdy5BbHBpbmUgPSBBbHBpbmU7XG4vLyBBbHBpbmUuc3RhcnQoKTtcblxuLyoqXG4gKiBFY2hvIGV4cG9zZXMgYW4gZXhwcmVzc2l2ZSBBUEkgZm9yIHN1YnNjcmliaW5nIHRvIGNoYW5uZWxzIGFuZCBsaXN0ZW5pbmdcbiAqIGZvciBldmVudHMgdGhhdCBhcmUgYnJvYWRjYXN0IGJ5IExhcmF2ZWwuIEVjaG8gYW5kIGV2ZW50IGJyb2FkY2FzdGluZ1xuICogYWxsb3dzIHlvdXIgdGVhbSB0byBlYXNpbHkgYnVpbGQgcm9idXN0IHJlYWwtdGltZSB3ZWIgYXBwbGljYXRpb25zLlxuICovXG5cbi8vIGltcG9ydCBFY2hvIGZyb20gJ2xhcmF2ZWwtZWNobydcblxuLy8gd2luZG93LlB1c2hlciA9IHJlcXVpcmUoJ3B1c2hlci1qcycpO1xuXG4vLyB3aW5kb3cuRWNobyA9IG5ldyBFY2hvKHtcbi8vICAgICBicm9hZGNhc3RlcjogJ3B1c2hlcicsXG4vLyAgICAga2V5OiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9LRVksXG4vLyAgICAgY2x1c3RlcjogcHJvY2Vzcy5lbnYuTUlYX1BVU0hFUl9BUFBfQ0xVU1RFUixcbi8vICAgICBmb3JjZVRMUzogdHJ1ZVxuLy8gfSk7XG5cbi8vIHdpbmRvdy50b2FzdHIgPSByZXF1aXJlKCd0b2FzdHInKTtcblxuLy8gdG9hc3RyLm9wdGlvbnMgPSB7XG4vLyAgICAgXCJjbG9zZUJ1dHRvblwiOiB0cnVlLFxuLy8gICAgIFwiZGVidWdcIjogZmFsc2UsXG4vLyAgICAgXCJuZXdlc3RPblRvcFwiOiBmYWxzZSxcbi8vICAgICBcInByb2dyZXNzQmFyXCI6IHRydWUsXG4vLyAgICAgXCJwb3NpdGlvbkNsYXNzXCI6IFwidG9hc3QtdG9wLXJpZ2h0XCIsXG4vLyAgICAgXCJwcmV2ZW50RHVwbGljYXRlc1wiOiBmYWxzZSxcbi8vICAgICBcIm9uY2xpY2tcIjogbnVsbCxcbi8vICAgICBcInNob3dEdXJhdGlvblwiOiBcIjMwMFwiLFxuLy8gICAgIFwiaGlkZUR1cmF0aW9uXCI6IFwiMTAwMFwiLFxuLy8gICAgIFwidGltZU91dFwiOiBcIjUwMDBcIixcbi8vICAgICBcImV4dGVuZGVkVGltZU91dFwiOiBcIjEwMDBcIixcbi8vICAgICBcInNob3dFYXNpbmdcIjogXCJzd2luZ1wiLFxuLy8gICAgIFwiaGlkZUVhc2luZ1wiOiBcImxpbmVhclwiLFxuLy8gICAgIFwic2hvd01ldGhvZFwiOiBcImZhZGVJblwiLFxuLy8gICAgIFwiaGlkZU1ldGhvZFwiOiBcImZhZGVPdXRcIlxuLy8gfVxuXG4vLyB3aW5kb3cubGl2ZXdpcmUub24oJ3RvYXN0cicsIHJlc3BvbnNlID0+IHtcbi8vICAgICB0b2FzdHJbcmVzcG9uc2VbJ3R5cGUnXV0ocmVzcG9uc2VbJ21lc3NhZ2UnXSwgcmVzcG9uc2VbJ3RpdGxlJ10pO1xuLy8gfSk7XG5cbi8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xpdmV3aXJlOmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgd2luZG93LmxpdmV3aXJlLm9uKCd0b2FzdHInLCByZXNwb25zZSA9PiB7XG4vLyAgICAgICAgIHRvYXN0cltyZXNwb25zZVsndHlwZSddXShyZXNwb25zZVsnbWVzc2FnZSddLCByZXNwb25zZVsndGl0bGUnXSk7XG4vLyAgICAgfSk7XG4vLyB9KSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hOTdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ "./node_modules/typeit/dist/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/typeit/dist/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TypeIt)\n/* harmony export */ });\n// TypeIt by Alex MacArthur - https://typeitjs.com\nconst isArray = (thing) => Array.isArray(thing);\n\nconst asArray = (value) => isArray(value) ? value : [value];\n\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      return _q.set(Symbol(step.char?.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    done,\n    reset,\n    destroy,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\n\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\n\nconst createElement = (el) => document.createElement(el);\n\nconst createTextNode = (content) => document.createTextNode(content);\n\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\n\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\n\nconst randomInRange = (value, range) => {\n  return Math.abs(\n    Math.random() * (value + range - (value - range)) + (value - range)\n  );\n};\n\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\n\nconst toArray = (val) => Array.from(val);\n\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\n\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\n\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      if (cursor && shouldIncludeCursor) {\n        if (node.classList?.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return node.classList?.contains(CURSOR_CLASS) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\n\nconst isNumber = (value) => Number.isInteger(value);\n\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\n\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\n\nconst duplicate = (value, times) => new Array(times).fill(value);\n\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\n\nlet getAnimationFromElement = (element) => {\n  return element?.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\n\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\n\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\n\nlet execute = (queueItem) => queueItem.func?.call(null);\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\n\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\n\nconst generateHash = () => Math.random().toString().substring(2, 9);\n\nconst isInput = (el) => {\n  return \"value\" in el;\n};\n\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\n\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\n\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\n\nlet isBodyElement = (node) => /body/i.test(node?.tagName);\n\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : (\n    // If we add one-off fresh elements, there will be no\n    // \"originalParent\", so always fall back to the default target.\n    character.originalParent || originalTarget\n  );\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\n\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\n\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\n\nlet processCursorOptions = (cursorOptions) => {\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = cursorOptions.animation?.frames || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      cursorOptions.animation?.options || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\n\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? (\n    // This parent still needs to exist.\n    node\n  ) : (\n    // There's nothing else in there, so just delete the entire thing.\n    // By doing this, we clean up markup as we go along.\n    nodeParent\n  );\n  nodeToRemove.remove();\n};\n\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = nodeToInsertBefore?.parentNode || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\n\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\n\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\n\nfunction splitOnBreak(str) {\n  return str.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n}\n\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\n\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\n\nclass TypeIt {\n  element;\n  timeouts;\n  cursorPosition;\n  predictedCursorPosition;\n  statuses = {\n    started: false,\n    completed: false,\n    frozen: false,\n    destroyed: false\n  };\n  opts;\n  id;\n  queue;\n  cursor;\n  unfreeze = () => {\n  };\n  constructor(element, options = {}) {\n    this.opts = merge(DEFAULT_OPTIONS, options);\n    this.element = selectorToElement(element);\n    this.timeouts = [];\n    this.cursorPosition = 0;\n    this.unfreeze = () => {\n    };\n    this.predictedCursorPosition = null;\n    this.statuses = merge({}, DEFAULT_STATUSES);\n    this.id = generateHash();\n    this.queue = Queue([{ delay: this.opts.startDelay }]);\n    this.#buildOptions(options);\n    this.cursor = this.#setUpCursor();\n    this.element.dataset.typeitId = this.id;\n    appendStyleBlock(PLACEHOLDER_CSS);\n    if (this.opts.strings.length) {\n      this.#generateQueue();\n    }\n  }\n  /**\n   * Can only be called once.\n   */\n  go() {\n    if (this.statuses.started) {\n      return this;\n    }\n    this.#attachCursor();\n    if (!this.opts.waitUntilVisible) {\n      this.#fire();\n      return this;\n    }\n    fireWhenVisible(this.element, this.#fire.bind(this));\n    return this;\n  }\n  destroy(shouldRemoveCursor = true) {\n    this.timeouts = destroyTimeouts(this.timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && this.cursor && this.#removeNode(this.cursor);\n    this.statuses.destroyed = true;\n  }\n  reset(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      this.queue.wipe();\n      rebuild(this);\n    } else {\n      this.queue.reset();\n    }\n    this.cursorPosition = 0;\n    for (let property in this.statuses) {\n      this.statuses[property] = false;\n    }\n    this.element[this.#elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  }\n  is = function(key) {\n    return this.statuses[key];\n  };\n  type(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = this.#generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, this.opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => this.#type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : this.#getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await this.opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await this.opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return this.#queueAndReturn(itemsToQueue, actionOpts);\n  }\n  break(actionOpts = {}) {\n    return this.#queueAndReturn(\n      {\n        func: () => this.#type(createElement(\"BR\")),\n        typeable: true\n      },\n      actionOpts\n    );\n  }\n  move(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = this.#generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: this.queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: this.#derivedCursorPosition\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    this.predictedCursorPosition = this.#derivedCursorPosition + numberOfSteps;\n    return this.#queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: () => this.#move(directionalStep),\n            delay: instant ? 0 : this.#getPace(),\n            cursorable: true\n          },\n          Math.abs(numberOfSteps)\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  }\n  exec(func, actionOpts = {}) {\n    let bookEndQueueItems = this.#generateTemporaryOptionQueueItems(actionOpts);\n    return this.#queueAndReturn(\n      [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]],\n      actionOpts\n    );\n  }\n  options(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    this.#updateOptions(opts);\n    return this.#queueAndReturn({}, actionOpts);\n  }\n  pause(milliseconds, actionOpts = {}) {\n    return this.#queueAndReturn(\n      { delay: handleFunctionalArg(milliseconds) },\n      actionOpts\n    );\n  }\n  delete(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = this.#generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = this.queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: this.#derivedCursorPosition,\n        to\n      });\n    })();\n    return this.#queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: this.#delete.bind(this),\n            delay: instant ? 0 : this.#getPace(1),\n            deletable: true\n          },\n          rounds\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  }\n  freeze() {\n    this.statuses.frozen = true;\n  }\n  /**\n   * Like `.go()`, but more... \"off the grid.\"\n   *\n   * - won't trigger `afterComplete` callback\n   * - items won't be replayed after `.reset()`\n   *\n   * When called, all non-done items will be \"flushed\" --\n   * that is, executed, but not remembered.\n   */\n  flush(cb = () => {\n  }) {\n    this.#attachCursor();\n    this.#fire(false).then(cb);\n    return this;\n  }\n  getQueue() {\n    return this.queue;\n  }\n  getOptions() {\n    return this.opts;\n  }\n  updateOptions(options) {\n    return this.#updateOptions(options);\n  }\n  getElement() {\n    return this.element;\n  }\n  empty(actionOpts = {}) {\n    return this.#queueAndReturn({ func: this.#empty.bind(this) }, actionOpts);\n  }\n  async #empty() {\n    if (this.#elementIsInput()) {\n      this.element.value = \"\";\n      return;\n    }\n    this.#allChars.forEach(this.#removeNode.bind(this));\n    return;\n  }\n  /**\n   * Execute items in the queue.\n   *\n   * @param remember If false, each queue item will be destroyed once executed.\n   * @returns\n   */\n  async #fire(remember = true) {\n    this.statuses.started = true;\n    let cleanUp = (qKey) => {\n      this.queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [...this.queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done)\n          continue;\n        if (!queueItem.deletable || queueItem.deletable && this.#allChars.length) {\n          let newIndex = await this.#fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return this;\n      }\n      this.statuses.completed = true;\n      await this.opts.afterComplete(this);\n      if (!this.opts.loop) {\n        throw \"\";\n      }\n      let delay = this.opts.loopDelay;\n      this.#wait(async () => {\n        await this.#prepLoop(delay[0]);\n        this.#fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  }\n  async #move(step) {\n    this.cursorPosition = updateCursorPosition(\n      step,\n      this.cursorPosition,\n      this.#allChars\n    );\n    repositionCursor(this.element, this.#allChars, this.cursorPosition);\n  }\n  /**\n   * 1. Reset queue.\n   * 2. Reset initial pause.\n   */\n  async #prepLoop(delay) {\n    let derivedCursorPosition = this.#derivedCursorPosition;\n    derivedCursorPosition && await this.#move({ value: derivedCursorPosition });\n    let queueItems = this.#allChars.map((c) => {\n      return [\n        Symbol(),\n        {\n          func: this.#delete.bind(this),\n          delay: this.#getPace(1),\n          deletable: true,\n          shouldPauseCursor: () => true\n        }\n      ];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await this.#fireItemWithContext(index, queueItems);\n    }\n    this.queue.reset();\n    this.queue.set(0, { delay });\n  }\n  #fireItemWithContext(index, queueItems) {\n    return fireItem({\n      index,\n      queueItems,\n      wait: this.#wait.bind(this),\n      cursor: this.cursor,\n      cursorOptions: this.opts.cursor\n    });\n  }\n  async #wait(callback, delay, silent = false) {\n    if (this.statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          this.statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await this.opts.beforeStep(this);\n    await wait(callback, delay, this.timeouts);\n    silent || await this.opts.afterStep(this);\n  }\n  /**\n   * Attach it to the DOM so, along with the required CSS transition.\n   */\n  async #attachCursor() {\n    !this.#elementIsInput() && this.cursor && this.element.appendChild(this.cursor);\n    if (this.#shouldRenderCursor) {\n      setCursorStyles(this.id, this.element);\n      this.cursor.dataset.tiAnimationId = this.id;\n      let { animation } = this.opts.cursor;\n      let { frames, options } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: this.cursor,\n        options: {\n          duration: this.opts.cursorSpeed,\n          ...options\n        }\n      });\n    }\n  }\n  #elementIsInput() {\n    return isInput(this.element);\n  }\n  #queueAndReturn(steps, opts) {\n    this.queue.add(steps);\n    this.#maybeAppendPause(opts);\n    return this;\n  }\n  #maybeAppendPause(opts = {}) {\n    let delay = opts.delay;\n    delay && this.queue.add({ delay });\n  }\n  #generateTemporaryOptionQueueItems(newOptions = {}) {\n    return [\n      { func: () => this.#updateOptions(newOptions) },\n      { func: () => this.#updateOptions(this.opts) }\n    ];\n  }\n  async #updateOptions(opts) {\n    this.opts = merge(this.opts, opts);\n  }\n  /**\n   * Based on provided strings, generate a TypeIt queue\n   * to be fired for each character in the string.\n   */\n  #generateQueue() {\n    let strings = this.opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = this.opts.breakLines ? [{ func: () => this.#type(createElement(\"BR\")), typeable: true }] : duplicate(\n        {\n          func: this.#delete.bind(this),\n          delay: this.#getPace(1)\n        },\n        this.queue.getTypeable().length\n      );\n      this.#addSplitPause(splitItems);\n    });\n  }\n  #buildOptions = (options) => {\n    options.cursor = processCursorOptions(\n      options.cursor ?? DEFAULT_OPTIONS.cursor\n    );\n    this.opts.strings = this.#prependHardcodedStrings(\n      asArray(this.opts.strings)\n    );\n    this.opts = merge(this.opts, {\n      html: !this.#isInput && this.opts.html,\n      nextStringDelay: calculateDelay(this.opts.nextStringDelay),\n      loopDelay: calculateDelay(this.opts.loopDelay)\n    });\n  };\n  #prependHardcodedStrings(strings) {\n    let existingMarkup = this.element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    this.element.innerHTML = \"\";\n    if (this.opts.startDelete) {\n      this.element.innerHTML = existingMarkup;\n      expandTextNodes(this.element);\n      this.#addSplitPause(\n        duplicate(\n          {\n            func: this.#delete.bind(this),\n            delay: this.#getPace(1),\n            deletable: true\n          },\n          this.#allChars.length\n        )\n      );\n      return strings;\n    }\n    return splitOnBreak(existingMarkup).concat(strings);\n  }\n  /**\n   * Provided it's a non-form element and the options is provided,\n   * set up the cursor element for the animation.\n   */\n  #setUpCursor() {\n    if (this.#isInput) {\n      return null;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!this.#shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(this.opts.cursorChar).innerHTML;\n    return cursor;\n  }\n  #addSplitPause(items) {\n    let delay = this.opts.nextStringDelay;\n    this.queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n  }\n  #type(char) {\n    insertIntoElement(this.element, char);\n  }\n  #delete() {\n    if (!this.#allChars.length)\n      return;\n    if (this.#isInput) {\n      this.element.value = this.element.value.slice(0, -1);\n    } else {\n      this.#removeNode(this.#allChars[this.cursorPosition]);\n    }\n  }\n  #removeNode(node) {\n    removeNode(node, this.element);\n  }\n  #getPace(index = 0) {\n    return calculatePace(this.opts)[index];\n  }\n  get #derivedCursorPosition() {\n    return this.predictedCursorPosition ?? this.cursorPosition;\n  }\n  get #isInput() {\n    return isInput(this.element);\n  }\n  get #shouldRenderCursor() {\n    return !!this.opts.cursor && !this.#isInput;\n  }\n  get #allChars() {\n    return getAllChars(this.element);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHlwZWl0L2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7QUFDNUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsVUFBVSxjQUFjLHVCQUF1QixVQUFVLG9CQUFvQjs7QUFFeEg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUIsRUFBRSxzQkFBc0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlLElBQUksR0FBRztBQUMvQywwQkFBMEIsY0FBYyxHQUFHLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsRUFBRSxLQUFLLG9CQUFvQixLQUFLLElBQUksOEJBQThCLEVBQUU7QUFDakcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0JBQWtCLHVCQUF1QixVQUFVLEVBQUUsbUJBQW1CO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwwQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLDhEQUE4RDtBQUN0RTtBQUNBLFFBQVEsNkRBQTZEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxRQUFRLDBDQUEwQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLFFBQVEsNkNBQTZDO0FBQ3JELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw2REFBNkQ7QUFDOUc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUIsY0FBYyxpQkFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlaXQvZGlzdC9pbmRleC5lcy5qcz9lZWZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFR5cGVJdCBieSBBbGV4IE1hY0FydGh1ciAtIGh0dHBzOi8vdHlwZWl0anMuY29tXG5jb25zdCBpc0FycmF5ID0gKHRoaW5nKSA9PiBBcnJheS5pc0FycmF5KHRoaW5nKTtcblxuY29uc3QgYXNBcnJheSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5cbmxldCBRdWV1ZSA9IGZ1bmN0aW9uKGluaXRpYWxJdGVtcykge1xuICBsZXQgYWRkID0gZnVuY3Rpb24oc3RlcHMpIHtcbiAgICBhc0FycmF5KHN0ZXBzKS5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICByZXR1cm4gX3Euc2V0KFN5bWJvbChzdGVwLmNoYXI/LmlubmVyVGV4dCksIGJ1aWxkUXVldWVJdGVtKHsgLi4uc3RlcCB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGxldCBnZXRUeXBlYWJsZSA9ICgpID0+IHJhd1ZhbHVlcygpLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnR5cGVhYmxlKTtcbiAgbGV0IHNldCA9IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgbGV0IGtleXMgPSBbLi4uX3Eua2V5cygpXTtcbiAgICBfcS5zZXQoa2V5c1tpbmRleF0sIGJ1aWxkUXVldWVJdGVtKGl0ZW0pKTtcbiAgfTtcbiAgbGV0IGJ1aWxkUXVldWVJdGVtID0gKHF1ZXVlSXRlbSkgPT4ge1xuICAgIHF1ZXVlSXRlbS5zaG91bGRQYXVzZUN1cnNvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy50eXBlYWJsZSB8fCB0aGlzLmN1cnNvcmFibGUgfHwgdGhpcy5kZWxldGFibGUpO1xuICAgIH07XG4gICAgcmV0dXJuIHF1ZXVlSXRlbTtcbiAgfTtcbiAgbGV0IHJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgX3EuZm9yRWFjaCgoaXRlbSkgPT4gZGVsZXRlIGl0ZW0uZG9uZSk7XG4gIH07XG4gIGxldCB3aXBlID0gZnVuY3Rpb24oKSB7XG4gICAgX3EgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGFkZChpbml0aWFsSXRlbXMpO1xuICB9O1xuICBsZXQgZ2V0UXVldWUgPSAoKSA9PiBfcTtcbiAgbGV0IHJhd1ZhbHVlcyA9ICgpID0+IEFycmF5LmZyb20oX3EudmFsdWVzKCkpO1xuICBsZXQgZGVzdHJveSA9IChrZXkpID0+IF9xLmRlbGV0ZShrZXkpO1xuICBsZXQgZ2V0SXRlbXMgPSAoYWxsID0gZmFsc2UpID0+IGFsbCA/IHJhd1ZhbHVlcygpIDogcmF3VmFsdWVzKCkuZmlsdGVyKChpKSA9PiAhaS5kb25lKTtcbiAgbGV0IGRvbmUgPSAoa2V5LCBzaG91bGREZXN0cm95ID0gZmFsc2UpID0+IHNob3VsZERlc3Ryb3kgPyBfcS5kZWxldGUoa2V5KSA6IF9xLmdldChrZXkpLmRvbmUgPSB0cnVlO1xuICBsZXQgX3EgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhZGQoaW5pdGlhbEl0ZW1zKTtcbiAgcmV0dXJuIHtcbiAgICBhZGQsXG4gICAgc2V0LFxuICAgIHdpcGUsXG4gICAgZG9uZSxcbiAgICByZXNldCxcbiAgICBkZXN0cm95LFxuICAgIGdldEl0ZW1zLFxuICAgIGdldFF1ZXVlLFxuICAgIGdldFR5cGVhYmxlXG4gIH07XG59O1xuXG5jb25zdCBEQVRBX0FUVFJJQlVURSA9IFwiZGF0YS10eXBlaXQtaWRcIjtcbmNvbnN0IENVUlNPUl9DTEFTUyA9IFwidGktY3Vyc29yXCI7XG5jb25zdCBFTkQgPSBcIkVORFwiO1xuY29uc3QgREVGQVVMVF9TVEFUVVNFUyA9IHtcbiAgc3RhcnRlZDogZmFsc2UsXG4gIGNvbXBsZXRlZDogZmFsc2UsXG4gIGZyb3plbjogZmFsc2UsXG4gIGRlc3Ryb3llZDogZmFsc2Vcbn07XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIGJyZWFrTGluZXM6IHRydWUsXG4gIGN1cnNvcjoge1xuICAgIGF1dG9QYXVzZTogdHJ1ZSxcbiAgICBhdXRvUGF1c2VEZWxheTogNTAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZnJhbWVzOiBbMCwgMCwgMV0ubWFwKChuKSA9PiB7XG4gICAgICAgIHJldHVybiB7IG9wYWNpdHk6IG4gfTtcbiAgICAgIH0pLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBpdGVyYXRpb25zOiBJbmZpbml0eSxcbiAgICAgICAgZWFzaW5nOiBcInN0ZXBzKDIsIHN0YXJ0KVwiLFxuICAgICAgICBmaWxsOiBcImZvcndhcmRzXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGN1cnNvckNoYXI6IFwifFwiLFxuICBjdXJzb3JTcGVlZDogMWUzLFxuICBkZWxldGVTcGVlZDogbnVsbCxcbiAgaHRtbDogdHJ1ZSxcbiAgbGlmZUxpa2U6IHRydWUsXG4gIGxvb3A6IGZhbHNlLFxuICBsb29wRGVsYXk6IDc1MCxcbiAgbmV4dFN0cmluZ0RlbGF5OiA3NTAsXG4gIHNwZWVkOiAxMDAsXG4gIHN0YXJ0RGVsYXk6IDI1MCxcbiAgc3RhcnREZWxldGU6IGZhbHNlLFxuICBzdHJpbmdzOiBbXSxcbiAgd2FpdFVudGlsVmlzaWJsZTogZmFsc2UsXG4gIGJlZm9yZVN0cmluZzogKCkgPT4ge1xuICB9LFxuICBhZnRlclN0cmluZzogKCkgPT4ge1xuICB9LFxuICBiZWZvcmVTdGVwOiAoKSA9PiB7XG4gIH0sXG4gIGFmdGVyU3RlcDogKCkgPT4ge1xuICB9LFxuICBhZnRlckNvbXBsZXRlOiAoKSA9PiB7XG4gIH1cbn07XG5jb25zdCBQTEFDRUhPTERFUl9DU1MgPSBgWyR7REFUQV9BVFRSSUJVVEV9XTpiZWZvcmUge2NvbnRlbnQ6ICcuJzsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMDsgdmlzaWJpbGl0eTogaGlkZGVuO31gO1xuXG5jb25zdCBjcmVhdGVFbGVtZW50ID0gKGVsKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsKTtcblxuY29uc3QgY3JlYXRlVGV4dE5vZGUgPSAoY29udGVudCkgPT4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCk7XG5cbmNvbnN0IGFwcGVuZFN0eWxlQmxvY2sgPSAoc3R5bGVzLCBpZCA9IFwiXCIpID0+IHtcbiAgbGV0IHN0eWxlQmxvY2sgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlQmxvY2suaWQgPSBpZDtcbiAgc3R5bGVCbG9jay5hcHBlbmRDaGlsZChjcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUJsb2NrKTtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZURlbGF5ID0gKGRlbGF5QXJnKSA9PiB7XG4gIGlmICghaXNBcnJheShkZWxheUFyZykpIHtcbiAgICBkZWxheUFyZyA9IFtkZWxheUFyZyAvIDIsIGRlbGF5QXJnIC8gMl07XG4gIH1cbiAgcmV0dXJuIGRlbGF5QXJnO1xufTtcblxuY29uc3QgcmFuZG9tSW5SYW5nZSA9ICh2YWx1ZSwgcmFuZ2UpID0+IHtcbiAgcmV0dXJuIE1hdGguYWJzKFxuICAgIE1hdGgucmFuZG9tKCkgKiAodmFsdWUgKyByYW5nZSAtICh2YWx1ZSAtIHJhbmdlKSkgKyAodmFsdWUgLSByYW5nZSlcbiAgKTtcbn07XG5cbmxldCByYW5nZSA9ICh2YWwpID0+IHZhbCAvIDI7XG5mdW5jdGlvbiBjYWxjdWxhdGVQYWNlKG9wdGlvbnMpIHtcbiAgbGV0IHsgc3BlZWQsIGRlbGV0ZVNwZWVkLCBsaWZlTGlrZSB9ID0gb3B0aW9ucztcbiAgZGVsZXRlU3BlZWQgPSBkZWxldGVTcGVlZCAhPT0gbnVsbCA/IGRlbGV0ZVNwZWVkIDogc3BlZWQgLyAzO1xuICByZXR1cm4gbGlmZUxpa2UgPyBbXG4gICAgcmFuZG9tSW5SYW5nZShzcGVlZCwgcmFuZ2Uoc3BlZWQpKSxcbiAgICByYW5kb21JblJhbmdlKGRlbGV0ZVNwZWVkLCByYW5nZShkZWxldGVTcGVlZCkpXG4gIF0gOiBbc3BlZWQsIGRlbGV0ZVNwZWVkXTtcbn1cblxuY29uc3QgdG9BcnJheSA9ICh2YWwpID0+IEFycmF5LmZyb20odmFsKTtcblxubGV0IGV4cGFuZFRleHROb2RlcyA9IChlbGVtZW50KSA9PiB7XG4gIFsuLi5lbGVtZW50LmNoaWxkTm9kZXNdLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgWy4uLmNoaWxkLm5vZGVWYWx1ZV0uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjaGlsZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjcmVhdGVUZXh0Tm9kZShjKSwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhwYW5kVGV4dE5vZGVzKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuY29uc3QgZ2V0UGFyc2VkQm9keSA9IChjb250ZW50KSA9PiB7XG4gIGxldCBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgZG9jLmJvZHkuaW5uZXJIVE1MID0gY29udGVudDtcbiAgcmV0dXJuIGV4cGFuZFRleHROb2Rlcyhkb2MuYm9keSk7XG59O1xuXG5mdW5jdGlvbiB3YWxrRWxlbWVudE5vZGVzKGVsZW1lbnQsIHNob3VsZFJldmVyc2UgPSBmYWxzZSwgc2hvdWxkSW5jbHVkZUN1cnNvciA9IGZhbHNlKSB7XG4gIGxldCBjdXJzb3IgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke0NVUlNPUl9DTEFTU31gKTtcbiAgbGV0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0FMTCwge1xuICAgIGFjY2VwdE5vZGU6IChub2RlKSA9PiB7XG4gICAgICBpZiAoY3Vyc29yICYmIHNob3VsZEluY2x1ZGVDdXJzb3IpIHtcbiAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0Py5jb250YWlucyhDVVJTT1JfQ0xBU1MpKSB7XG4gICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyc29yLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0Py5jb250YWlucyhDVVJTT1JfQ0xBU1MpID8gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUIDogTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cbiAgfSk7XG4gIGxldCBuZXh0Tm9kZTtcbiAgbGV0IG5vZGVzID0gW107XG4gIHdoaWxlIChuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgaWYgKCFuZXh0Tm9kZS5vcmlnaW5hbFBhcmVudCkge1xuICAgICAgbmV4dE5vZGUub3JpZ2luYWxQYXJlbnQgPSBuZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKG5leHROb2RlKTtcbiAgfVxuICByZXR1cm4gc2hvdWxkUmV2ZXJzZSA/IG5vZGVzLnJldmVyc2UoKSA6IG5vZGVzO1xufVxuZnVuY3Rpb24gY2h1bmtTdHJpbmdBc0h0bWwoc3RyaW5nKSB7XG4gIHJldHVybiB3YWxrRWxlbWVudE5vZGVzKGdldFBhcnNlZEJvZHkoc3RyaW5nKSk7XG59XG5mdW5jdGlvbiBtYXliZUNodW5rU3RyaW5nQXNIdG1sKHN0ciwgYXNIdG1sID0gdHJ1ZSkge1xuICByZXR1cm4gYXNIdG1sID8gY2h1bmtTdHJpbmdBc0h0bWwoc3RyKSA6IHRvQXJyYXkoc3RyKS5tYXAoY3JlYXRlVGV4dE5vZGUpO1xufVxuXG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5cbmNvbnN0IGNvdW50U3RlcHNUb1NlbGVjdG9yID0gKHtcbiAgcXVldWVJdGVtcyxcbiAgc2VsZWN0b3IsXG4gIGN1cnNvclBvc2l0aW9uLFxuICB0b1xufSkgPT4ge1xuICBpZiAoaXNOdW1iZXIoc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yICogLTE7XG4gIH1cbiAgbGV0IGlzTW92aW5nVG9FbmQgPSBuZXcgUmVnRXhwKEVORCwgXCJpXCIpLnRlc3QodG8pO1xuICBsZXQgc2VsZWN0b3JJbmRleCA9IHNlbGVjdG9yID8gWy4uLnF1ZXVlSXRlbXNdLnJldmVyc2UoKS5maW5kSW5kZXgoKHsgY2hhciB9KSA9PiB7XG4gICAgbGV0IHBhcmVudEVsZW1lbnQgPSBjaGFyLnBhcmVudEVsZW1lbnQ7XG4gICAgbGV0IHBhcmVudE1hdGNoZXMgPSBwYXJlbnRFbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIGlmIChpc01vdmluZ1RvRW5kICYmIHBhcmVudE1hdGNoZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50TWF0Y2hlcyAmJiBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQuaXNTYW1lTm9kZShjaGFyKTtcbiAgfSkgOiAtMTtcbiAgaWYgKHNlbGVjdG9ySW5kZXggPCAwKSB7XG4gICAgc2VsZWN0b3JJbmRleCA9IGlzTW92aW5nVG9FbmQgPyAwIDogcXVldWVJdGVtcy5sZW5ndGggLSAxO1xuICB9XG4gIGxldCBvZmZzZXQgPSBpc01vdmluZ1RvRW5kID8gMCA6IDE7XG4gIHJldHVybiBzZWxlY3RvckluZGV4IC0gY3Vyc29yUG9zaXRpb24gKyBvZmZzZXQ7XG59O1xuXG5jb25zdCBkZXN0cm95VGltZW91dHMgPSAodGltZW91dHMpID0+IHtcbiAgdGltZW91dHMuZm9yRWFjaChjbGVhclRpbWVvdXQpO1xuICByZXR1cm4gW107XG59O1xuXG5jb25zdCBkdXBsaWNhdGUgPSAodmFsdWUsIHRpbWVzKSA9PiBuZXcgQXJyYXkodGltZXMpLmZpbGwodmFsdWUpO1xuXG5sZXQgYmVmb3JlUGFpbnQgPSAoY2IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFzeW5jICgpID0+IHtcbiAgICAgIHJlc29sdmUoYXdhaXQgY2IoKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxubGV0IGdldEFuaW1hdGlvbkZyb21FbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgcmV0dXJuIGVsZW1lbnQ/LmdldEFuaW1hdGlvbnMoKS5maW5kKChhbmltYXRpb24pID0+IHtcbiAgICByZXR1cm4gYW5pbWF0aW9uLmlkID09PSBlbGVtZW50LmRhdGFzZXQudGlBbmltYXRpb25JZDtcbiAgfSk7XG59O1xuXG5sZXQgc2V0Q3Vyc29yQW5pbWF0aW9uID0gKHtcbiAgY3Vyc29yLFxuICBmcmFtZXMsXG4gIG9wdGlvbnNcbn0pID0+IHtcbiAgbGV0IGFuaW1hdGlvbiA9IGN1cnNvci5hbmltYXRlKGZyYW1lcywgb3B0aW9ucyk7XG4gIGFuaW1hdGlvbi5wYXVzZSgpO1xuICBhbmltYXRpb24uaWQgPSBjdXJzb3IuZGF0YXNldC50aUFuaW1hdGlvbklkO1xuICBiZWZvcmVQYWludCgoKSA9PiB7XG4gICAgYmVmb3JlUGFpbnQoKCkgPT4ge1xuICAgICAgYW5pbWF0aW9uLnBsYXkoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhbmltYXRpb247XG59O1xuXG5sZXQgcmVidWlsZEN1cnNvckFuaW1hdGlvbiA9ICh7XG4gIGN1cnNvcixcbiAgb3B0aW9ucyxcbiAgY3Vyc29yT3B0aW9uc1xufSkgPT4ge1xuICBpZiAoIWN1cnNvciB8fCAhY3Vyc29yT3B0aW9ucylcbiAgICByZXR1cm47XG4gIGxldCBhbmltYXRpb24gPSBnZXRBbmltYXRpb25Gcm9tRWxlbWVudChjdXJzb3IpO1xuICBsZXQgb2xkQ3VycmVudFRpbWU7XG4gIGlmIChhbmltYXRpb24pIHtcbiAgICBvcHRpb25zLmRlbGF5ID0gYW5pbWF0aW9uLmVmZmVjdC5nZXRDb21wdXRlZFRpbWluZygpLmRlbGF5O1xuICAgIG9sZEN1cnJlbnRUaW1lID0gYW5pbWF0aW9uLmN1cnJlbnRUaW1lO1xuICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgfVxuICBsZXQgbmV3QW5pbWF0aW9uID0gc2V0Q3Vyc29yQW5pbWF0aW9uKHtcbiAgICBjdXJzb3IsXG4gICAgZnJhbWVzOiBjdXJzb3JPcHRpb25zLmFuaW1hdGlvbi5mcmFtZXMsXG4gICAgb3B0aW9uc1xuICB9KTtcbiAgaWYgKG9sZEN1cnJlbnRUaW1lKSB7XG4gICAgbmV3QW5pbWF0aW9uLmN1cnJlbnRUaW1lID0gb2xkQ3VycmVudFRpbWU7XG4gIH1cbiAgcmV0dXJuIG5ld0FuaW1hdGlvbjtcbn07XG5cbmxldCBleGVjdXRlID0gKHF1ZXVlSXRlbSkgPT4gcXVldWVJdGVtLmZ1bmM/LmNhbGwobnVsbCk7XG5sZXQgZmlyZUl0ZW0gPSBhc3luYyAoe1xuICBpbmRleCxcbiAgcXVldWVJdGVtcyxcbiAgd2FpdCxcbiAgY3Vyc29yLFxuICBjdXJzb3JPcHRpb25zXG59KSA9PiB7XG4gIGxldCBxdWV1ZUl0ZW0gPSBxdWV1ZUl0ZW1zW2luZGV4XVsxXTtcbiAgbGV0IGluc3RhbnRRdWV1ZSA9IFtdO1xuICBsZXQgdGVtcEluZGV4ID0gaW5kZXg7XG4gIGxldCBmdXR1cmVJdGVtID0gcXVldWVJdGVtO1xuICBsZXQgc2hvdWxkQmVHcm91cGVkID0gKCkgPT4gZnV0dXJlSXRlbSAmJiAhZnV0dXJlSXRlbS5kZWxheTtcbiAgbGV0IHNob3VsZFBhdXNlQ3Vyc29yID0gcXVldWVJdGVtLnNob3VsZFBhdXNlQ3Vyc29yKCkgJiYgY3Vyc29yT3B0aW9ucy5hdXRvUGF1c2U7XG4gIHdoaWxlIChzaG91bGRCZUdyb3VwZWQoKSkge1xuICAgIGluc3RhbnRRdWV1ZS5wdXNoKGZ1dHVyZUl0ZW0pO1xuICAgIHNob3VsZEJlR3JvdXBlZCgpICYmIHRlbXBJbmRleCsrO1xuICAgIGZ1dHVyZUl0ZW0gPSBxdWV1ZUl0ZW1zW3RlbXBJbmRleF0gPyBxdWV1ZUl0ZW1zW3RlbXBJbmRleF1bMV0gOiBudWxsO1xuICB9XG4gIGlmIChpbnN0YW50UXVldWUubGVuZ3RoKSB7XG4gICAgYXdhaXQgYmVmb3JlUGFpbnQoYXN5bmMgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgcSBvZiBpbnN0YW50UXVldWUpIHtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZShxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGVtcEluZGV4IC0gMTtcbiAgfVxuICBsZXQgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uRnJvbUVsZW1lbnQoY3Vyc29yKTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChhbmltYXRpb24pIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgLi4uYW5pbWF0aW9uLmVmZmVjdC5nZXRDb21wdXRlZFRpbWluZygpLFxuICAgICAgZGVsYXk6IHNob3VsZFBhdXNlQ3Vyc29yID8gY3Vyc29yT3B0aW9ucy5hdXRvUGF1c2VEZWxheSA6IDBcbiAgICB9O1xuICB9XG4gIGF3YWl0IHdhaXQoYXN5bmMgKCkgPT4ge1xuICAgIGlmIChhbmltYXRpb24gJiYgc2hvdWxkUGF1c2VDdXJzb3IpIHtcbiAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICB9XG4gICAgYXdhaXQgYmVmb3JlUGFpbnQoKCkgPT4ge1xuICAgICAgZXhlY3V0ZShxdWV1ZUl0ZW0pO1xuICAgIH0pO1xuICB9LCBxdWV1ZUl0ZW0uZGVsYXkpO1xuICBhd2FpdCByZWJ1aWxkQ3Vyc29yQW5pbWF0aW9uKHtcbiAgICBjdXJzb3IsXG4gICAgb3B0aW9ucyxcbiAgICBjdXJzb3JPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gaW5kZXg7XG59O1xuXG5jb25zdCBmaXJlV2hlblZpc2libGUgPSAoZWxlbWVudCwgZnVuYykgPT4ge1xuICBsZXQgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgKGVudHJpZXMsIG9ic2VydmVyMikgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB7IHRocmVzaG9sZDogMSB9XG4gICk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG59O1xuXG5jb25zdCBnZW5lcmF0ZUhhc2ggPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsIDkpO1xuXG5jb25zdCBpc0lucHV0ID0gKGVsKSA9PiB7XG4gIHJldHVybiBcInZhbHVlXCIgaW4gZWw7XG59O1xuXG5sZXQgZ2V0QWxsQ2hhcnMgPSAoZWxlbWVudCkgPT4ge1xuICBpZiAoaXNJbnB1dChlbGVtZW50KSkge1xuICAgIHJldHVybiB0b0FycmF5KGVsZW1lbnQudmFsdWUpO1xuICB9XG4gIHJldHVybiB3YWxrRWxlbWVudE5vZGVzKGVsZW1lbnQsIHRydWUpLmZpbHRlcihcbiAgICAoYykgPT4gIShjLmNoaWxkTm9kZXMubGVuZ3RoID4gMClcbiAgKTtcbn07XG5cbmxldCBoYW5kbGVGdW5jdGlvbmFsQXJnID0gKGFyZykgPT4ge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKCkgOiBhcmc7XG59O1xuXG5sZXQgc2VsZWN0ID0gKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQsIGFsbCA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiBlbGVtZW50W2BxdWVyeVNlbGVjdG9yJHthbGwgPyBcIkFsbFwiIDogXCJcIn1gXShzZWxlY3Rvcik7XG59O1xuXG5sZXQgaXNCb2R5RWxlbWVudCA9IChub2RlKSA9PiAvYm9keS9pLnRlc3Qobm9kZT8udGFnTmFtZSk7XG5cbmxldCBpbnNlcnRJbnRvRWxlbWVudCA9IChvcmlnaW5hbFRhcmdldCwgY2hhcmFjdGVyKSA9PiB7XG4gIGlmIChpc0lucHV0KG9yaWdpbmFsVGFyZ2V0KSkge1xuICAgIG9yaWdpbmFsVGFyZ2V0LnZhbHVlID0gYCR7b3JpZ2luYWxUYXJnZXQudmFsdWV9JHtjaGFyYWN0ZXIudGV4dENvbnRlbnR9YDtcbiAgICByZXR1cm47XG4gIH1cbiAgY2hhcmFjdGVyLmlubmVySFRNTCA9IFwiXCI7XG4gIGxldCB0YXJnZXQgPSBpc0JvZHlFbGVtZW50KGNoYXJhY3Rlci5vcmlnaW5hbFBhcmVudCkgPyBvcmlnaW5hbFRhcmdldCA6IChcbiAgICAvLyBJZiB3ZSBhZGQgb25lLW9mZiBmcmVzaCBlbGVtZW50cywgdGhlcmUgd2lsbCBiZSBub1xuICAgIC8vIFwib3JpZ2luYWxQYXJlbnRcIiwgc28gYWx3YXlzIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCB0YXJnZXQuXG4gICAgY2hhcmFjdGVyLm9yaWdpbmFsUGFyZW50IHx8IG9yaWdpbmFsVGFyZ2V0XG4gICk7XG4gIHRhcmdldC5pbnNlcnRCZWZvcmUoXG4gICAgY2hhcmFjdGVyLFxuICAgIHNlbGVjdChcIi5cIiArIENVUlNPUl9DTEFTUywgdGFyZ2V0KSB8fCBudWxsXG4gICk7XG59O1xuXG5jb25zdCBpc05vblZvaWRFbGVtZW50ID0gKGVsKSA9PiAvPCguKyk+KC4qPyk8XFwvKC4rKT4vLnRlc3QoZWwub3V0ZXJIVE1MKTtcblxuY29uc3QgbWVyZ2UgPSAob3JpZ2luYWxPYmosIG5ld09iaikgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxPYmosIG5ld09iaik7XG5cbmxldCBwcm9jZXNzQ3Vyc29yT3B0aW9ucyA9IChjdXJzb3JPcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2YgY3Vyc29yT3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgIGxldCBuZXdPcHRpb25zID0ge307XG4gICAgbGV0IHsgZnJhbWVzOiBkZWZhdWx0RnJhbWVzLCBvcHRpb25zOiBkZWZhdWx0T3B0aW9ucyB9ID0gREVGQVVMVF9PUFRJT05TLmN1cnNvci5hbmltYXRpb247XG4gICAgbmV3T3B0aW9ucy5hbmltYXRpb24gPSBjdXJzb3JPcHRpb25zLmFuaW1hdGlvbiB8fCB7fTtcbiAgICBuZXdPcHRpb25zLmFuaW1hdGlvbi5mcmFtZXMgPSBjdXJzb3JPcHRpb25zLmFuaW1hdGlvbj8uZnJhbWVzIHx8IGRlZmF1bHRGcmFtZXM7XG4gICAgbmV3T3B0aW9ucy5hbmltYXRpb24ub3B0aW9ucyA9IG1lcmdlKFxuICAgICAgZGVmYXVsdE9wdGlvbnMsXG4gICAgICBjdXJzb3JPcHRpb25zLmFuaW1hdGlvbj8ub3B0aW9ucyB8fCB7fVxuICAgICk7XG4gICAgbmV3T3B0aW9ucy5hdXRvUGF1c2UgPSBjdXJzb3JPcHRpb25zLmF1dG9QYXVzZSA/PyBERUZBVUxUX09QVElPTlMuY3Vyc29yLmF1dG9QYXVzZTtcbiAgICBuZXdPcHRpb25zLmF1dG9QYXVzZURlbGF5ID0gY3Vyc29yT3B0aW9ucy5hdXRvUGF1c2VEZWxheSB8fCBERUZBVUxUX09QVElPTlMuY3Vyc29yLmF1dG9QYXVzZURlbGF5O1xuICAgIHJldHVybiBuZXdPcHRpb25zO1xuICB9XG4gIGlmIChjdXJzb3JPcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfT1BUSU9OUy5jdXJzb3I7XG4gIH1cbiAgcmV0dXJuIGN1cnNvck9wdGlvbnM7XG59O1xuXG5jb25zdCByZW1vdmVOb2RlID0gKG5vZGUsIHJvb3RFbGVtZW50KSA9PiB7XG4gIGlmICghbm9kZSlcbiAgICByZXR1cm47XG4gIGxldCBub2RlUGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICBsZXQgbm9kZVRvUmVtb3ZlID0gbm9kZVBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHwgbm9kZVBhcmVudC5pc1NhbWVOb2RlKHJvb3RFbGVtZW50KSA/IChcbiAgICAvLyBUaGlzIHBhcmVudCBzdGlsbCBuZWVkcyB0byBleGlzdC5cbiAgICBub2RlXG4gICkgOiAoXG4gICAgLy8gVGhlcmUncyBub3RoaW5nIGVsc2UgaW4gdGhlcmUsIHNvIGp1c3QgZGVsZXRlIHRoZSBlbnRpcmUgdGhpbmcuXG4gICAgLy8gQnkgZG9pbmcgdGhpcywgd2UgY2xlYW4gdXAgbWFya3VwIGFzIHdlIGdvIGFsb25nLlxuICAgIG5vZGVQYXJlbnRcbiAgKTtcbiAgbm9kZVRvUmVtb3ZlLnJlbW92ZSgpO1xufTtcblxuY29uc3QgcmVwb3NpdGlvbkN1cnNvciA9IChlbGVtZW50LCBhbGxDaGFycywgbmV3Q3Vyc29yUG9zaXRpb24pID0+IHtcbiAgbGV0IG5vZGVUb0luc2VydEJlZm9yZSA9IGFsbENoYXJzW25ld0N1cnNvclBvc2l0aW9uIC0gMV07XG4gIGxldCBjdXJzb3IgPSBzZWxlY3QoYC4ke0NVUlNPUl9DTEFTU31gLCBlbGVtZW50KTtcbiAgZWxlbWVudCA9IG5vZGVUb0luc2VydEJlZm9yZT8ucGFyZW50Tm9kZSB8fCBlbGVtZW50O1xuICBlbGVtZW50Lmluc2VydEJlZm9yZShjdXJzb3IsIG5vZGVUb0luc2VydEJlZm9yZSB8fCBudWxsKTtcbn07XG5cbmZ1bmN0aW9uIHNlbGVjdG9yVG9FbGVtZW50KHRoaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwic3RyaW5nXCIgPyBzZWxlY3QodGhpbmcpIDogdGhpbmc7XG59XG5cbmxldCBjdXJzb3JGb250U3R5bGVzID0ge1xuICBcImZvbnQtZmFtaWx5XCI6IFwiXCIsXG4gIFwiZm9udC13ZWlnaHRcIjogXCJcIixcbiAgXCJmb250LXNpemVcIjogXCJcIixcbiAgXCJmb250LXN0eWxlXCI6IFwiXCIsXG4gIFwibGluZS1oZWlnaHRcIjogXCJcIixcbiAgY29sb3I6IFwiXCIsXG4gIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKC0uMTI1ZW0pXCJcbn07XG5sZXQgc2V0Q3Vyc29yU3R5bGVzID0gKGlkLCBlbGVtZW50KSA9PiB7XG4gIGxldCByb290U2VsZWN0b3IgPSBgWyR7REFUQV9BVFRSSUJVVEV9PScke2lkfSddYDtcbiAgbGV0IGN1cnNvclNlbGVjdG9yID0gYCR7cm9vdFNlbGVjdG9yfSAuJHtDVVJTT1JfQ0xBU1N9YDtcbiAgbGV0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgbGV0IGN1c3RvbVByb3BlcnRpZXMgPSBPYmplY3QuZW50cmllcyhjdXJzb3JGb250U3R5bGVzKS5yZWR1Y2UoXG4gICAgKGFjY3VtdWxhdG9yLCBbaXRlbSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gYCR7YWNjdW11bGF0b3J9ICR7aXRlbX06IHZhcigtLXRpLWN1cnNvci0ke2l0ZW19LCAke3ZhbHVlIHx8IGNvbXB1dGVkU3R5bGVzW2l0ZW1dfSk7YDtcbiAgICB9LFxuICAgIFwiXCJcbiAgKTtcbiAgYXBwZW5kU3R5bGVCbG9jayhcbiAgICBgJHtjdXJzb3JTZWxlY3Rvcn0geyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAwOyAke2N1c3RvbVByb3BlcnRpZXN9IH1gLFxuICAgIGlkXG4gICk7XG59O1xuXG5mdW5jdGlvbiBzcGxpdE9uQnJlYWsoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvPCEtLSguKz8pLS0+L2csIFwiXCIpLnRyaW0oKS5zcGxpdCgvPGJyKD86XFxzKj8pKD86XFwvKT8+Lyk7XG59XG5cbmxldCB1cGRhdGVDdXJzb3JQb3NpdGlvbiA9IChzdGVwcywgY3Vyc29yUG9zaXRpb24sIHByaW50ZWRDaGFyYWN0ZXJzKSA9PiB7XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBNYXRoLm1heChjdXJzb3JQb3NpdGlvbiArIHN0ZXBzLCAwKSxcbiAgICBwcmludGVkQ2hhcmFjdGVycy5sZW5ndGhcbiAgKTtcbn07XG5cbmxldCB3YWl0ID0gKGNhbGxiYWNrLCBkZWxheSwgdGltZW91dHMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbGV0IGNiID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgY2FsbGJhY2soKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIHRpbWVvdXRzLnB1c2goc2V0VGltZW91dChjYiwgZGVsYXkgfHwgMCkpO1xuICB9KTtcbn07XG5cbmNsYXNzIFR5cGVJdCB7XG4gIGVsZW1lbnQ7XG4gIHRpbWVvdXRzO1xuICBjdXJzb3JQb3NpdGlvbjtcbiAgcHJlZGljdGVkQ3Vyc29yUG9zaXRpb247XG4gIHN0YXR1c2VzID0ge1xuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgZnJvemVuOiBmYWxzZSxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlXG4gIH07XG4gIG9wdHM7XG4gIGlkO1xuICBxdWV1ZTtcbiAgY3Vyc29yO1xuICB1bmZyZWV6ZSA9ICgpID0+IHtcbiAgfTtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRzID0gbWVyZ2UoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBzZWxlY3RvclRvRWxlbWVudChlbGVtZW50KTtcbiAgICB0aGlzLnRpbWVvdXRzID0gW107XG4gICAgdGhpcy5jdXJzb3JQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy51bmZyZWV6ZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIHRoaXMucHJlZGljdGVkQ3Vyc29yUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuc3RhdHVzZXMgPSBtZXJnZSh7fSwgREVGQVVMVF9TVEFUVVNFUyk7XG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlSGFzaCgpO1xuICAgIHRoaXMucXVldWUgPSBRdWV1ZShbeyBkZWxheTogdGhpcy5vcHRzLnN0YXJ0RGVsYXkgfV0pO1xuICAgIHRoaXMuI2J1aWxkT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMuI3NldFVwQ3Vyc29yKCk7XG4gICAgdGhpcy5lbGVtZW50LmRhdGFzZXQudHlwZWl0SWQgPSB0aGlzLmlkO1xuICAgIGFwcGVuZFN0eWxlQmxvY2soUExBQ0VIT0xERVJfQ1NTKTtcbiAgICBpZiAodGhpcy5vcHRzLnN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLiNnZW5lcmF0ZVF1ZXVlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYW4gb25seSBiZSBjYWxsZWQgb25jZS5cbiAgICovXG4gIGdvKCkge1xuICAgIGlmICh0aGlzLnN0YXR1c2VzLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLiNhdHRhY2hDdXJzb3IoKTtcbiAgICBpZiAoIXRoaXMub3B0cy53YWl0VW50aWxWaXNpYmxlKSB7XG4gICAgICB0aGlzLiNmaXJlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmlyZVdoZW5WaXNpYmxlKHRoaXMuZWxlbWVudCwgdGhpcy4jZmlyZS5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KHNob3VsZFJlbW92ZUN1cnNvciA9IHRydWUpIHtcbiAgICB0aGlzLnRpbWVvdXRzID0gZGVzdHJveVRpbWVvdXRzKHRoaXMudGltZW91dHMpO1xuICAgIGhhbmRsZUZ1bmN0aW9uYWxBcmcoc2hvdWxkUmVtb3ZlQ3Vyc29yKSAmJiB0aGlzLmN1cnNvciAmJiB0aGlzLiNyZW1vdmVOb2RlKHRoaXMuY3Vyc29yKTtcbiAgICB0aGlzLnN0YXR1c2VzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgcmVzZXQocmVidWlsZCkge1xuICAgICF0aGlzLmlzKFwiZGVzdHJveWVkXCIpICYmIHRoaXMuZGVzdHJveSgpO1xuICAgIGlmIChyZWJ1aWxkKSB7XG4gICAgICB0aGlzLnF1ZXVlLndpcGUoKTtcbiAgICAgIHJlYnVpbGQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVldWUucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJzb3JQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5zdGF0dXNlcykge1xuICAgICAgdGhpcy5zdGF0dXNlc1twcm9wZXJ0eV0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50W3RoaXMuI2VsZW1lbnRJc0lucHV0KCkgPyBcInZhbHVlXCIgOiBcImlubmVySFRNTFwiXSA9IFwiXCI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNlc1trZXldO1xuICB9O1xuICB0eXBlKHN0cmluZywgYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgc3RyaW5nID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhzdHJpbmcpO1xuICAgIGxldCB7IGluc3RhbnQgfSA9IGFjdGlvbk9wdHM7XG4gICAgbGV0IGJvb2tFbmRRdWV1ZUl0ZW1zID0gdGhpcy4jZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zKGFjdGlvbk9wdHMpO1xuICAgIGxldCBjaGFycyA9IG1heWJlQ2h1bmtTdHJpbmdBc0h0bWwoc3RyaW5nLCB0aGlzLm9wdHMuaHRtbCk7XG4gICAgbGV0IGNoYXJzQXNRdWV1ZUl0ZW1zID0gY2hhcnMubWFwKChjaGFyKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmdW5jOiAoKSA9PiB0aGlzLiN0eXBlKGNoYXIpLFxuICAgICAgICBjaGFyLFxuICAgICAgICBkZWxheTogaW5zdGFudCB8fCBpc05vblZvaWRFbGVtZW50KGNoYXIpID8gMCA6IHRoaXMuI2dldFBhY2UoKSxcbiAgICAgICAgdHlwZWFibGU6IGNoYXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGxldCBpdGVtc1RvUXVldWUgPSBbXG4gICAgICBib29rRW5kUXVldWVJdGVtc1swXSxcbiAgICAgIHsgZnVuYzogYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5vcHRzLmJlZm9yZVN0cmluZyhzdHJpbmcsIHRoaXMpIH0sXG4gICAgICAuLi5jaGFyc0FzUXVldWVJdGVtcyxcbiAgICAgIHsgZnVuYzogYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5vcHRzLmFmdGVyU3RyaW5nKHN0cmluZywgdGhpcykgfSxcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzFdXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcy4jcXVldWVBbmRSZXR1cm4oaXRlbXNUb1F1ZXVlLCBhY3Rpb25PcHRzKTtcbiAgfVxuICBicmVhayhhY3Rpb25PcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy4jcXVldWVBbmRSZXR1cm4oXG4gICAgICB7XG4gICAgICAgIGZ1bmM6ICgpID0+IHRoaXMuI3R5cGUoY3JlYXRlRWxlbWVudChcIkJSXCIpKSxcbiAgICAgICAgdHlwZWFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBhY3Rpb25PcHRzXG4gICAgKTtcbiAgfVxuICBtb3ZlKG1vdmVtZW50QXJnLCBhY3Rpb25PcHRzID0ge30pIHtcbiAgICBtb3ZlbWVudEFyZyA9IGhhbmRsZUZ1bmN0aW9uYWxBcmcobW92ZW1lbnRBcmcpO1xuICAgIGxldCBib29rRW5kUXVldWVJdGVtcyA9IHRoaXMuI2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyhhY3Rpb25PcHRzKTtcbiAgICBsZXQgeyBpbnN0YW50LCB0byB9ID0gYWN0aW9uT3B0cztcbiAgICBsZXQgbnVtYmVyT2ZTdGVwcyA9IGNvdW50U3RlcHNUb1NlbGVjdG9yKHtcbiAgICAgIHF1ZXVlSXRlbXM6IHRoaXMucXVldWUuZ2V0VHlwZWFibGUoKSxcbiAgICAgIHNlbGVjdG9yOiBtb3ZlbWVudEFyZyA9PT0gbnVsbCA/IFwiXCIgOiBtb3ZlbWVudEFyZyxcbiAgICAgIHRvLFxuICAgICAgY3Vyc29yUG9zaXRpb246IHRoaXMuI2Rlcml2ZWRDdXJzb3JQb3NpdGlvblxuICAgIH0pO1xuICAgIGxldCBkaXJlY3Rpb25hbFN0ZXAgPSBudW1iZXJPZlN0ZXBzIDwgMCA/IC0xIDogMTtcbiAgICB0aGlzLnByZWRpY3RlZEN1cnNvclBvc2l0aW9uID0gdGhpcy4jZGVyaXZlZEN1cnNvclBvc2l0aW9uICsgbnVtYmVyT2ZTdGVwcztcbiAgICByZXR1cm4gdGhpcy4jcXVldWVBbmRSZXR1cm4oXG4gICAgICBbXG4gICAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzBdLFxuICAgICAgICAuLi5kdXBsaWNhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZnVuYzogKCkgPT4gdGhpcy4jbW92ZShkaXJlY3Rpb25hbFN0ZXApLFxuICAgICAgICAgICAgZGVsYXk6IGluc3RhbnQgPyAwIDogdGhpcy4jZ2V0UGFjZSgpLFxuICAgICAgICAgICAgY3Vyc29yYWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgTWF0aC5hYnMobnVtYmVyT2ZTdGVwcylcbiAgICAgICAgKSxcbiAgICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMV1cbiAgICAgIF0sXG4gICAgICBhY3Rpb25PcHRzXG4gICAgKTtcbiAgfVxuICBleGVjKGZ1bmMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIGxldCBib29rRW5kUXVldWVJdGVtcyA9IHRoaXMuI2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyhhY3Rpb25PcHRzKTtcbiAgICByZXR1cm4gdGhpcy4jcXVldWVBbmRSZXR1cm4oXG4gICAgICBbYm9va0VuZFF1ZXVlSXRlbXNbMF0sIHsgZnVuYzogKCkgPT4gZnVuYyh0aGlzKSB9LCBib29rRW5kUXVldWVJdGVtc1sxXV0sXG4gICAgICBhY3Rpb25PcHRzXG4gICAgKTtcbiAgfVxuICBvcHRpb25zKG9wdHMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIG9wdHMgPSBoYW5kbGVGdW5jdGlvbmFsQXJnKG9wdHMpO1xuICAgIHRoaXMuI3VwZGF0ZU9wdGlvbnMob3B0cyk7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXVlQW5kUmV0dXJuKHt9LCBhY3Rpb25PcHRzKTtcbiAgfVxuICBwYXVzZShtaWxsaXNlY29uZHMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLiNxdWV1ZUFuZFJldHVybihcbiAgICAgIHsgZGVsYXk6IGhhbmRsZUZ1bmN0aW9uYWxBcmcobWlsbGlzZWNvbmRzKSB9LFxuICAgICAgYWN0aW9uT3B0c1xuICAgICk7XG4gIH1cbiAgZGVsZXRlKG51bUNoYXJhY3RlcnMgPSBudWxsLCBhY3Rpb25PcHRzID0ge30pIHtcbiAgICBudW1DaGFyYWN0ZXJzID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhudW1DaGFyYWN0ZXJzKTtcbiAgICBsZXQgYm9va0VuZFF1ZXVlSXRlbXMgPSB0aGlzLiNnZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXMoYWN0aW9uT3B0cyk7XG4gICAgbGV0IG51bSA9IG51bUNoYXJhY3RlcnM7XG4gICAgbGV0IHsgaW5zdGFudCwgdG8gfSA9IGFjdGlvbk9wdHM7XG4gICAgbGV0IHR5cGVhYmxlUXVldWVJdGVtcyA9IHRoaXMucXVldWUuZ2V0VHlwZWFibGUoKTtcbiAgICBsZXQgcm91bmRzID0gKCgpID0+IHtcbiAgICAgIGlmIChudW0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVhYmxlUXVldWVJdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIobnVtKSkge1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50U3RlcHNUb1NlbGVjdG9yKHtcbiAgICAgICAgcXVldWVJdGVtczogdHlwZWFibGVRdWV1ZUl0ZW1zLFxuICAgICAgICBzZWxlY3RvcjogbnVtLFxuICAgICAgICBjdXJzb3JQb3NpdGlvbjogdGhpcy4jZGVyaXZlZEN1cnNvclBvc2l0aW9uLFxuICAgICAgICB0b1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gdGhpcy4jcXVldWVBbmRSZXR1cm4oXG4gICAgICBbXG4gICAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzBdLFxuICAgICAgICAuLi5kdXBsaWNhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZnVuYzogdGhpcy4jZGVsZXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxheTogaW5zdGFudCA/IDAgOiB0aGlzLiNnZXRQYWNlKDEpLFxuICAgICAgICAgICAgZGVsZXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICByb3VuZHNcbiAgICAgICAgKSxcbiAgICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMV1cbiAgICAgIF0sXG4gICAgICBhY3Rpb25PcHRzXG4gICAgKTtcbiAgfVxuICBmcmVlemUoKSB7XG4gICAgdGhpcy5zdGF0dXNlcy5mcm96ZW4gPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBMaWtlIGAuZ28oKWAsIGJ1dCBtb3JlLi4uIFwib2ZmIHRoZSBncmlkLlwiXG4gICAqXG4gICAqIC0gd29uJ3QgdHJpZ2dlciBgYWZ0ZXJDb21wbGV0ZWAgY2FsbGJhY2tcbiAgICogLSBpdGVtcyB3b24ndCBiZSByZXBsYXllZCBhZnRlciBgLnJlc2V0KClgXG4gICAqXG4gICAqIFdoZW4gY2FsbGVkLCBhbGwgbm9uLWRvbmUgaXRlbXMgd2lsbCBiZSBcImZsdXNoZWRcIiAtLVxuICAgKiB0aGF0IGlzLCBleGVjdXRlZCwgYnV0IG5vdCByZW1lbWJlcmVkLlxuICAgKi9cbiAgZmx1c2goY2IgPSAoKSA9PiB7XG4gIH0pIHtcbiAgICB0aGlzLiNhdHRhY2hDdXJzb3IoKTtcbiAgICB0aGlzLiNmaXJlKGZhbHNlKS50aGVuKGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRRdWV1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM7XG4gIH1cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICB9XG4gIGVtcHR5KGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLiNxdWV1ZUFuZFJldHVybih7IGZ1bmM6IHRoaXMuI2VtcHR5LmJpbmQodGhpcykgfSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgYXN5bmMgI2VtcHR5KCkge1xuICAgIGlmICh0aGlzLiNlbGVtZW50SXNJbnB1dCgpKSB7XG4gICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBcIlwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbGxDaGFycy5mb3JFYWNoKHRoaXMuI3JlbW92ZU5vZGUuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIGl0ZW1zIGluIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHJlbWVtYmVyIElmIGZhbHNlLCBlYWNoIHF1ZXVlIGl0ZW0gd2lsbCBiZSBkZXN0cm95ZWQgb25jZSBleGVjdXRlZC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jICNmaXJlKHJlbWVtYmVyID0gdHJ1ZSkge1xuICAgIHRoaXMuc3RhdHVzZXMuc3RhcnRlZCA9IHRydWU7XG4gICAgbGV0IGNsZWFuVXAgPSAocUtleSkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5kb25lKHFLZXksICFyZW1lbWJlcik7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgbGV0IHF1ZXVlSXRlbXMgPSBbLi4udGhpcy5xdWV1ZS5nZXRRdWV1ZSgpXTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZUl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBsZXQgW3F1ZXVlS2V5LCBxdWV1ZUl0ZW1dID0gcXVldWVJdGVtc1tpbmRleF07XG4gICAgICAgIGlmIChxdWV1ZUl0ZW0uZG9uZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFxdWV1ZUl0ZW0uZGVsZXRhYmxlIHx8IHF1ZXVlSXRlbS5kZWxldGFibGUgJiYgdGhpcy4jYWxsQ2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IG5ld0luZGV4ID0gYXdhaXQgdGhpcy4jZmlyZUl0ZW1XaXRoQ29udGV4dChpbmRleCwgcXVldWVJdGVtcyk7XG4gICAgICAgICAgQXJyYXkobmV3SW5kZXggLSBpbmRleCkuZmlsbChpbmRleCArIDEpLm1hcCgoeCwgeSkgPT4geCArIHkpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgICAgIGxldCBba2V5XSA9IHF1ZXVlSXRlbXNbaV07XG4gICAgICAgICAgICBjbGVhblVwKGtleSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjbGVhblVwKHF1ZXVlS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVtZW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXR1c2VzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICBhd2FpdCB0aGlzLm9wdHMuYWZ0ZXJDb21wbGV0ZSh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5vcHRzLmxvb3ApIHtcbiAgICAgICAgdGhyb3cgXCJcIjtcbiAgICAgIH1cbiAgICAgIGxldCBkZWxheSA9IHRoaXMub3B0cy5sb29wRGVsYXk7XG4gICAgICB0aGlzLiN3YWl0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcHJlcExvb3AoZGVsYXlbMF0pO1xuICAgICAgICB0aGlzLiNmaXJlKCk7XG4gICAgICB9LCBkZWxheVsxXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyAjbW92ZShzdGVwKSB7XG4gICAgdGhpcy5jdXJzb3JQb3NpdGlvbiA9IHVwZGF0ZUN1cnNvclBvc2l0aW9uKFxuICAgICAgc3RlcCxcbiAgICAgIHRoaXMuY3Vyc29yUG9zaXRpb24sXG4gICAgICB0aGlzLiNhbGxDaGFyc1xuICAgICk7XG4gICAgcmVwb3NpdGlvbkN1cnNvcih0aGlzLmVsZW1lbnQsIHRoaXMuI2FsbENoYXJzLCB0aGlzLmN1cnNvclBvc2l0aW9uKTtcbiAgfVxuICAvKipcbiAgICogMS4gUmVzZXQgcXVldWUuXG4gICAqIDIuIFJlc2V0IGluaXRpYWwgcGF1c2UuXG4gICAqL1xuICBhc3luYyAjcHJlcExvb3AoZGVsYXkpIHtcbiAgICBsZXQgZGVyaXZlZEN1cnNvclBvc2l0aW9uID0gdGhpcy4jZGVyaXZlZEN1cnNvclBvc2l0aW9uO1xuICAgIGRlcml2ZWRDdXJzb3JQb3NpdGlvbiAmJiBhd2FpdCB0aGlzLiNtb3ZlKHsgdmFsdWU6IGRlcml2ZWRDdXJzb3JQb3NpdGlvbiB9KTtcbiAgICBsZXQgcXVldWVJdGVtcyA9IHRoaXMuI2FsbENoYXJzLm1hcCgoYykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgU3ltYm9sKCksXG4gICAgICAgIHtcbiAgICAgICAgICBmdW5jOiB0aGlzLiNkZWxldGUuYmluZCh0aGlzKSxcbiAgICAgICAgICBkZWxheTogdGhpcy4jZ2V0UGFjZSgxKSxcbiAgICAgICAgICBkZWxldGFibGU6IHRydWUsXG4gICAgICAgICAgc2hvdWxkUGF1c2VDdXJzb3I6ICgpID0+IHRydWVcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcXVldWVJdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGF3YWl0IHRoaXMuI2ZpcmVJdGVtV2l0aENvbnRleHQoaW5kZXgsIHF1ZXVlSXRlbXMpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlLnJlc2V0KCk7XG4gICAgdGhpcy5xdWV1ZS5zZXQoMCwgeyBkZWxheSB9KTtcbiAgfVxuICAjZmlyZUl0ZW1XaXRoQ29udGV4dChpbmRleCwgcXVldWVJdGVtcykge1xuICAgIHJldHVybiBmaXJlSXRlbSh7XG4gICAgICBpbmRleCxcbiAgICAgIHF1ZXVlSXRlbXMsXG4gICAgICB3YWl0OiB0aGlzLiN3YWl0LmJpbmQodGhpcyksXG4gICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yLFxuICAgICAgY3Vyc29yT3B0aW9uczogdGhpcy5vcHRzLmN1cnNvclxuICAgIH0pO1xuICB9XG4gIGFzeW5jICN3YWl0KGNhbGxiYWNrLCBkZWxheSwgc2lsZW50ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0dXNlcy5mcm96ZW4pIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRoaXMudW5mcmVlemUgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0dXNlcy5mcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2lsZW50IHx8IGF3YWl0IHRoaXMub3B0cy5iZWZvcmVTdGVwKHRoaXMpO1xuICAgIGF3YWl0IHdhaXQoY2FsbGJhY2ssIGRlbGF5LCB0aGlzLnRpbWVvdXRzKTtcbiAgICBzaWxlbnQgfHwgYXdhaXQgdGhpcy5vcHRzLmFmdGVyU3RlcCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIGl0IHRvIHRoZSBET00gc28sIGFsb25nIHdpdGggdGhlIHJlcXVpcmVkIENTUyB0cmFuc2l0aW9uLlxuICAgKi9cbiAgYXN5bmMgI2F0dGFjaEN1cnNvcigpIHtcbiAgICAhdGhpcy4jZWxlbWVudElzSW5wdXQoKSAmJiB0aGlzLmN1cnNvciAmJiB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jdXJzb3IpO1xuICAgIGlmICh0aGlzLiNzaG91bGRSZW5kZXJDdXJzb3IpIHtcbiAgICAgIHNldEN1cnNvclN0eWxlcyh0aGlzLmlkLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgdGhpcy5jdXJzb3IuZGF0YXNldC50aUFuaW1hdGlvbklkID0gdGhpcy5pZDtcbiAgICAgIGxldCB7IGFuaW1hdGlvbiB9ID0gdGhpcy5vcHRzLmN1cnNvcjtcbiAgICAgIGxldCB7IGZyYW1lcywgb3B0aW9ucyB9ID0gYW5pbWF0aW9uO1xuICAgICAgc2V0Q3Vyc29yQW5pbWF0aW9uKHtcbiAgICAgICAgZnJhbWVzLFxuICAgICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0cy5jdXJzb3JTcGVlZCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjZWxlbWVudElzSW5wdXQoKSB7XG4gICAgcmV0dXJuIGlzSW5wdXQodGhpcy5lbGVtZW50KTtcbiAgfVxuICAjcXVldWVBbmRSZXR1cm4oc3RlcHMsIG9wdHMpIHtcbiAgICB0aGlzLnF1ZXVlLmFkZChzdGVwcyk7XG4gICAgdGhpcy4jbWF5YmVBcHBlbmRQYXVzZShvcHRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAjbWF5YmVBcHBlbmRQYXVzZShvcHRzID0ge30pIHtcbiAgICBsZXQgZGVsYXkgPSBvcHRzLmRlbGF5O1xuICAgIGRlbGF5ICYmIHRoaXMucXVldWUuYWRkKHsgZGVsYXkgfSk7XG4gIH1cbiAgI2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyhuZXdPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyBmdW5jOiAoKSA9PiB0aGlzLiN1cGRhdGVPcHRpb25zKG5ld09wdGlvbnMpIH0sXG4gICAgICB7IGZ1bmM6ICgpID0+IHRoaXMuI3VwZGF0ZU9wdGlvbnModGhpcy5vcHRzKSB9XG4gICAgXTtcbiAgfVxuICBhc3luYyAjdXBkYXRlT3B0aW9ucyhvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gbWVyZ2UodGhpcy5vcHRzLCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogQmFzZWQgb24gcHJvdmlkZWQgc3RyaW5ncywgZ2VuZXJhdGUgYSBUeXBlSXQgcXVldWVcbiAgICogdG8gYmUgZmlyZWQgZm9yIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXG4gICAqL1xuICAjZ2VuZXJhdGVRdWV1ZSgpIHtcbiAgICBsZXQgc3RyaW5ncyA9IHRoaXMub3B0cy5zdHJpbmdzLmZpbHRlcigoc3RyaW5nKSA9PiAhIXN0cmluZyk7XG4gICAgc3RyaW5ncy5mb3JFYWNoKChzdHJpbmcsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLnR5cGUoc3RyaW5nKTtcbiAgICAgIGlmIChpbmRleCArIDEgPT09IHN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzcGxpdEl0ZW1zID0gdGhpcy5vcHRzLmJyZWFrTGluZXMgPyBbeyBmdW5jOiAoKSA9PiB0aGlzLiN0eXBlKGNyZWF0ZUVsZW1lbnQoXCJCUlwiKSksIHR5cGVhYmxlOiB0cnVlIH1dIDogZHVwbGljYXRlKFxuICAgICAgICB7XG4gICAgICAgICAgZnVuYzogdGhpcy4jZGVsZXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgZGVsYXk6IHRoaXMuI2dldFBhY2UoMSlcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5xdWV1ZS5nZXRUeXBlYWJsZSgpLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHRoaXMuI2FkZFNwbGl0UGF1c2Uoc3BsaXRJdGVtcyk7XG4gICAgfSk7XG4gIH1cbiAgI2J1aWxkT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgb3B0aW9ucy5jdXJzb3IgPSBwcm9jZXNzQ3Vyc29yT3B0aW9ucyhcbiAgICAgIG9wdGlvbnMuY3Vyc29yID8/IERFRkFVTFRfT1BUSU9OUy5jdXJzb3JcbiAgICApO1xuICAgIHRoaXMub3B0cy5zdHJpbmdzID0gdGhpcy4jcHJlcGVuZEhhcmRjb2RlZFN0cmluZ3MoXG4gICAgICBhc0FycmF5KHRoaXMub3B0cy5zdHJpbmdzKVxuICAgICk7XG4gICAgdGhpcy5vcHRzID0gbWVyZ2UodGhpcy5vcHRzLCB7XG4gICAgICBodG1sOiAhdGhpcy4jaXNJbnB1dCAmJiB0aGlzLm9wdHMuaHRtbCxcbiAgICAgIG5leHRTdHJpbmdEZWxheTogY2FsY3VsYXRlRGVsYXkodGhpcy5vcHRzLm5leHRTdHJpbmdEZWxheSksXG4gICAgICBsb29wRGVsYXk6IGNhbGN1bGF0ZURlbGF5KHRoaXMub3B0cy5sb29wRGVsYXkpXG4gICAgfSk7XG4gIH07XG4gICNwcmVwZW5kSGFyZGNvZGVkU3RyaW5ncyhzdHJpbmdzKSB7XG4gICAgbGV0IGV4aXN0aW5nTWFya3VwID0gdGhpcy5lbGVtZW50LmlubmVySFRNTDtcbiAgICBpZiAoIWV4aXN0aW5nTWFya3VwKSB7XG4gICAgICByZXR1cm4gc3RyaW5ncztcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgaWYgKHRoaXMub3B0cy5zdGFydERlbGV0ZSkge1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGV4aXN0aW5nTWFya3VwO1xuICAgICAgZXhwYW5kVGV4dE5vZGVzKHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLiNhZGRTcGxpdFBhdXNlKFxuICAgICAgICBkdXBsaWNhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZnVuYzogdGhpcy4jZGVsZXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxheTogdGhpcy4jZ2V0UGFjZSgxKSxcbiAgICAgICAgICAgIGRlbGV0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy4jYWxsQ2hhcnMubGVuZ3RoXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gc3RyaW5ncztcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0T25CcmVhayhleGlzdGluZ01hcmt1cCkuY29uY2F0KHN0cmluZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlZCBpdCdzIGEgbm9uLWZvcm0gZWxlbWVudCBhbmQgdGhlIG9wdGlvbnMgaXMgcHJvdmlkZWQsXG4gICAqIHNldCB1cCB0aGUgY3Vyc29yIGVsZW1lbnQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICAjc2V0VXBDdXJzb3IoKSB7XG4gICAgaWYgKHRoaXMuI2lzSW5wdXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgY3Vyc29yID0gY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY3Vyc29yLmNsYXNzTmFtZSA9IENVUlNPUl9DTEFTUztcbiAgICBpZiAoIXRoaXMuI3Nob3VsZFJlbmRlckN1cnNvcikge1xuICAgICAgY3Vyc29yLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgY3Vyc29yLmlubmVySFRNTCA9IGdldFBhcnNlZEJvZHkodGhpcy5vcHRzLmN1cnNvckNoYXIpLmlubmVySFRNTDtcbiAgICByZXR1cm4gY3Vyc29yO1xuICB9XG4gICNhZGRTcGxpdFBhdXNlKGl0ZW1zKSB7XG4gICAgbGV0IGRlbGF5ID0gdGhpcy5vcHRzLm5leHRTdHJpbmdEZWxheTtcbiAgICB0aGlzLnF1ZXVlLmFkZChbeyBkZWxheTogZGVsYXlbMF0gfSwgLi4uaXRlbXMsIHsgZGVsYXk6IGRlbGF5WzFdIH1dKTtcbiAgfVxuICAjdHlwZShjaGFyKSB7XG4gICAgaW5zZXJ0SW50b0VsZW1lbnQodGhpcy5lbGVtZW50LCBjaGFyKTtcbiAgfVxuICAjZGVsZXRlKCkge1xuICAgIGlmICghdGhpcy4jYWxsQ2hhcnMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLiNpc0lucHV0KSB7XG4gICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSB0aGlzLmVsZW1lbnQudmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW1vdmVOb2RlKHRoaXMuI2FsbENoYXJzW3RoaXMuY3Vyc29yUG9zaXRpb25dKTtcbiAgICB9XG4gIH1cbiAgI3JlbW92ZU5vZGUobm9kZSkge1xuICAgIHJlbW92ZU5vZGUobm9kZSwgdGhpcy5lbGVtZW50KTtcbiAgfVxuICAjZ2V0UGFjZShpbmRleCA9IDApIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlUGFjZSh0aGlzLm9wdHMpW2luZGV4XTtcbiAgfVxuICBnZXQgI2Rlcml2ZWRDdXJzb3JQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVkaWN0ZWRDdXJzb3JQb3NpdGlvbiA/PyB0aGlzLmN1cnNvclBvc2l0aW9uO1xuICB9XG4gIGdldCAjaXNJbnB1dCgpIHtcbiAgICByZXR1cm4gaXNJbnB1dCh0aGlzLmVsZW1lbnQpO1xuICB9XG4gIGdldCAjc2hvdWxkUmVuZGVyQ3Vyc29yKCkge1xuICAgIHJldHVybiAhIXRoaXMub3B0cy5jdXJzb3IgJiYgIXRoaXMuI2lzSW5wdXQ7XG4gIH1cbiAgZ2V0ICNhbGxDaGFycygpIHtcbiAgICByZXR1cm4gZ2V0QWxsQ2hhcnModGhpcy5lbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBUeXBlSXQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/typeit/dist/index.es.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;